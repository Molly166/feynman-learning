好的，这是为您的《大前端与AI实战》实训课程设计的第十二次课程的详细内容。这次课程将开启一个新的篇章，从AI应用转向高级前端可视化，为项目增加炫酷的视觉效果和更直观的知识关联展示。

---

### **《大前端与AI实战》第十二次课程：知识图谱可视化**

**课程主题：** 点亮知识的网：使用图表库实现知识图谱可视化
**总时长：** 4学时 (约3-3.5小时教学，半小时答疑与休息)

#### **一、 本次课程目标 (Objectives)**

在本次课程结束后，每位同学都应该能够：
1.  **理解** 知识图谱的基本概念：节点（Nodes）和边（Edges）。
2.  **在后端设计并实现** 一个API，用于生成知识图谱所需的数据结构（节点列表和边列表）。
3.  **选择并集成** 一个主流的前端图表库，如 `AntV G6` 或 `ECharts`。
4.  **在前端** 创建一个新的页面，用于渲染和展示知识图谱。
5.  **实现** 知识图谱的基本交互功能，例如：
    *   鼠标悬停在高亮节点和边上。
    *   点击节点可以跳转到对应的知识点详情页或弹出信息框。
    *   拖拽节点以调整布局。

#### **二、 核心关键词 (Keywords)**

*   知识图谱 (Knowledge Graph)
*   节点 (Node) / 顶点 (Vertex)
*   边 (Edge) / 关系 (Relation)
*   力导向图 (Force-directed Layout)
*   `AntV G6` / `ECharts`
*   图数据结构

---

### **三、 详细教学流程 (Step-by-Step Guide)**

---

#### **第一部分：理论与后端准备 (约75分钟)**

**教师讲解与带领后端编码：**

1.  **回顾与承接**
    *   “上节课，我们成功打造了一个能与私有知识库对话的AI助手。到目前为止，我们都是通过列表或文本来查看知识点。但知识之间不是孤立的，它们相互关联。如何直观地看到‘React Hooks’和‘useEffect’以及‘useState’之间的关系呢？今天，我们就用一种非常酷的方式——知识图谱——来可视化这些联系。”

2.  **知识图谱概念入门**
    *   **讲解：** “知识图谱本质上就是一个‘图’（Graph），由两部分组成：”
        *   **节点 (Nodes):** 代表实体。在我们的项目中，每一个**知识点**就是一个节点。
        *   **边 (Edges):** 代表实体之间的关系。比如，知识点A的内容中提到了知识点B的标题，我们就可以认为A和B之间有一条从A指向B的边，表示‘引用’关系。
    *   **可视化方案：** “我们将使用‘力导向图’布局。想象一下，每个节点都带同种电荷相互排斥，而有关系的节点之间有一根弹簧把它们拉近。最终，整个图会达到一个动态平衡状态，形成一个看起来很自然的网络结构。”
    *   **技术选型：** “我们将使用 `Apache ECharts`，这是一个由百度开源的、应用极其广泛的数据可视化库。它的配置项非常丰富，社区活跃，能够轻松实现我们想要的力导向知识图谱效果。”

3.  **后端API设计与实现**
    *   **目标：** 创建一个API，如 `GET /api/graph/knowledge-map`，它能返回ECharts需要的JSON数据格式。
    *   **ECharts图谱数据格式：**
        ```json
        {
          "nodes": [
            { "id": "node1_id", "name": "知识点A标题", "value": "一些描述", "symbolSize": 50 },
            { "id": "node2_id", "name": "知识点B标题", "value": "...", "symbolSize": 30 }
          ],
          "links": [
            { "source": "node1_id", "target": "node2_id", "label": { "show": true, "formatter": "引用" } }
          ]
        }
        ```
    *   **实现关系发现的逻辑（简化版）：**
        *   **讲解：** “如何自动发现关系？一个简单有效的方法是：遍历所有知识点，检查每个知识点A的`content`中，是否包含了其他知识点B的`title`。如果包含，就建立一条从A到B的边。”
        *   **在后端新建路由文件 `routes/graph.js` (或添加到ai.js)：**
            ```javascript
            // routes/graph.js
            const express = require('express');
            const router = express.Router();
            const auth = require('../middleware/auth');
            const KnowledgePoint = require('../models/KnowledgePoint');

            // @route   GET /api/graph/knowledge-map
            // @desc    获取知识图谱数据
            // @access  Private
            router.get('/knowledge-map', auth, async (req, res) => {
                try {
                    const kps = await KnowledgePoint.find({ user: req.user.id });

                    if (kps.length === 0) {
                        return res.json({ nodes: [], links: [] });
                    }

                    const nodes = kps.map(kp => ({
                        id: kp._id.toString(),
                        name: kp.title,
                        value: kp.content.substring(0, 100), // 截取部分内容作为提示
                        symbolSize: 20 + Math.min(kp.content.length / 50, 30),
                    }));

                    const links = [];
                    const kpTitleMap = new Map(kps.map(kp => [kp.title, kp._id.toString()]));

                    for (const sourceKp of kps) {
                        for (const targetTitle of kpTitleMap.keys()) {
                            if (sourceKp.title === targetTitle) continue;
                            if (sourceKp.content.includes(targetTitle)) {
                                links.push({
                                    source: sourceKp._id.toString(),
                                    target: kpTitleMap.get(targetTitle),
                                });
                            }
                        }
                    }

                    res.json({ nodes, links });

                } catch (error) {
                    console.error('Error generating knowledge graph:', error);
                    res.status(500).send('Server Error');
                }
            });

            module.exports = router;
            ```
        *   **在 `index.js` 中使用路由：** `app.use('/api/graph', require('./routes/graph'));`
    *   **使用Postman测试：** `GET /api/graph/knowledge-map`，确保返回了正确的JSON结构（`nodes`和`links`）。

---

#### **第二部分：前端集成ECharts实现可视化 (约120分钟)**

**教师带领学生前端编码：**

1.  **安装 ECharts for React**
    *   在前端项目 (`feynman-platform-frontend`) 终端中安装：
        ```bash
        npm install echarts-for-react echarts
        ```

2.  **创建知识图谱页面组件**
    *   在 `src/pages` 下新建 `GraphPage.jsx`。
    *   **编写 `GraphPage.jsx`：**
        ```jsx
        // src/pages/GraphPage.jsx
        import { useEffect, useState } from 'react';
        import apiClient from '../api/axios';
        import ReactECharts from 'echarts-for-react';
        import { useNavigate } from 'react-router-dom';

        function GraphPage() {
            const [option, setOption] = useState({});
            const [loading, setLoading] = useState(true);
            const navigate = useNavigate();

            useEffect(() => {
                const fetchData = async () => {
                    try {
                        const response = await apiClient.get('/graph/knowledge-map');
                        const graphData = response.data;

                        const chartOption = {
                            tooltip: {},
                            series: [
                                {
                                    type: 'graph',
                                    layout: 'force',
                                    data: graphData.nodes,
                                    links: graphData.links,
                                    roam: true, // 开启鼠标缩放和平移漫游
                                    label: {
                                        show: true,
                                        position: 'right',
                                        formatter: '{b}' // {b} 表示节点名称
                                    },
                                    force: {
                                        repulsion: 100, // 节点之间的斥力因子
                                        edgeLength: 50
                                    },
                                    emphasis: {
                                        focus: 'adjacency',
                                        lineStyle: {
                                            width: 10
                                        }
                                    }
                                }
                            ]
                        };
                        setOption(chartOption);
                        setLoading(false);
                    } catch (error) {
                        console.error('获取图谱数据失败', error);
                        setLoading(false);
                    }
                };
                fetchData();
            }, []);

            const onChartClick = (params) => {
                if (params.componentType === 'series' && params.dataType === 'node') {
                    const nodeId = params.data.id;
                    navigate(`/kp/edit/${nodeId}`);
                }
            };

            if (loading) {
                return <p>正在生成知识图谱...</p>;
            }

            return (
                <div>
                    <h1>知识图谱</h1>
                    <p>展示知识点之间的引用关系。点击节点可进行编辑。</p>
                    <ReactECharts
                        option={option}
                        style={{ height: '600px', width: '100%' }}
                        onEvents={{ 'click': onChartClick }}
                    />
                </div>
            );
        }

        export default GraphPage;
        ```

3.  **添加路由和入口**
    *   在 `App.jsx` 中添加路由：`<Route path="/graph" element={<GraphPage />} />`
    *   在主布局 `Layout.jsx` 的导航栏中，添加一个指向 `/graph` 的链接，如“知识图谱”。

---

#### **第三部分：联调与美化 (15分钟)**

1.  **全流程联调：**
    *   确保后端有几个相互引用的知识点。
    *   启动前后端服务。
    *   导航到“知识图谱”页面。
    *   观察图谱是否成功渲染。
    *   **交互测试：**
        *   尝试拖拽画布、缩放画布。
        *   尝试拖拽节点。
        *   鼠标悬停在节点上，看是否有高亮效果（需要配置 `setItemState`）。
        *   点击一个节点，看是否能正确跳转到对应的编辑页面。

2.  **美化与定制（作为扩展方向讲解）**
    *   **讲解 G6 的强大定制能力：**
        *   **自定义节点/边样式：** 可以根据节点的属性（如`status`）来改变颜色。例如，已掌握的知识点是绿色，复习中的是橙色。
        *   **Tooltip（提示框）：** 鼠标悬停在节点上时，显示一个包含更详细信息的浮动框。
        *   **自定义交互：** 可以实现更复杂的交互，比如点击节点时，只高亮它和它的一度关系邻居。
        *   **动画效果：** G6支持丰富的动画，让图谱更生动。

    *   **演示一个简单的定制（修改节点颜色）：**
        ```javascript
        // 伪代码，在G6配置中
        // ...
        graph.data({
          nodes: graphData.nodes.map(node => ({
            ...node,
            style: {
              fill: node.status === 'mastered' ? 'green' : (node.reviewList ? 'orange' : '#5B8FF9'),
              //...
            },
          })),
          edges: graphData.edges,
        });
        // ...
        // 这需要后端API返回节点时也包含status和reviewList信息
        ```

---

#### **四、 课堂总结与作业**

*   **总结：**
    *   “今天，我们为‘费曼学习平台’开启了全新的维度——可视化。我们不仅学会了知识图谱的基本理论，还亲手实现了从后端数据构建到前端渲染的全过程。通过 AntV G6，我们把抽象的知识关联变成了直观、可交互的网络图。这不仅让我们的应用看起来更专业、更酷，也为用户提供了一种全新的、宏观的视角来审视自己的知识体系。”
*   **课后作业：**
    1.  **必须完成：** 确保知识图谱页面可以正常渲染，并实现基本的悬停和点击跳转交互。
    2.  **功能增强（挑战）：**
        *   **后端增强：** 修改 `GET /api/graph/knowledge-map` API，让返回的节点数据中包含 `status` 和 `reviewList` 字段。
        *   **前端定制：** 在 `GraphPage.jsx` 中，根据后端返回的 `status` 和 `reviewList` 字段，为不同状态的节点设置不同的颜色（例如：`mastered`为绿色，`reviewList`为`true`的为橙色，其他为蓝色）。
    3.  **探索 G6 Tooltip（选做）：** 阅读G6文档，为图谱添加 Tooltip 插件，当鼠标悬停在节点上时，显示一个包含知识点标题和创建时间的小卡片。
*   **预告下次课内容：**
    *   “二维的可视化已经很酷了，但‘大前端’的边界远不止于此。下一次课，我们将进入三维的世界，学习 `Three.js` 的基础，把我们的知识图谱从平面网络升级为三维的‘知识星球宇宙’，这将是一次充满想象力和创造力的旅程！”