好的，这是为您的《大前端与AI实战》实训课程设计的第六次课程的详细内容。本次课程将专注于项目核心功能的实现，即知识点管理，并引入富文本渲染技术，让学习内容生动起来。

---

### **《大前端与AI实战》第六次课程：知识点模块与富文本渲染**

**课程主题：** 内容为王：知识点CRUD与动态内容渲染
**总时长：** 4学时 (约3-3.5小时教学，半小时答疑与休息)

#### **一、 本次课程目标 (Objectives)**

在本次课程结束后，每位同学都应该能够：
1.  **在前端实现** 完整的知识点 CRUD (创建、读取、更新、删除) 功能，并与后端 API 对接。
2.  **创建** 知识点列表页 (`DashboardPage`) 和一个用于创建/编辑知识点的表单页。
3.  **使用 `react-markdown`** 在页面上安全地渲染用户输入的 Markdown 内容。
4.  **集成并配置 `remark-gfm`** 插件，以支持表格、删除线等扩展 Markdown 语法。
5.  **（挑战目标）初步集成 `react-katex`**，以支持在 Markdown 中渲染 LaTeX 数学公式。
6.  **（挑战目标）初步集成 `mermaid`**，以支持在 Markdown 中渲染流程图和图表。

#### **二、 核心关键词 (Keywords)**

*   CRUD (前端实现)
*   `useEffect` Hook
*   Modal (模态框) / Page for Forms
*   Markdown
*   `react-markdown`
*   `remark-gfm` (GitHub Flavored Markdown)
*   `react-katex` (LaTeX)
*   `mermaid`

---

### **三、 详细教学流程 (Step-by-Step Guide)**

---

#### **第一部分：知识点展示与获取 (约60分钟)**

**教师讲解与带领编码：**

1.  **回顾与承接**
    *   “上节课我们打通了前后端，实现了完整的用户认证流程。大家的作业（根据登录状态显示不同导航栏）完成得怎么样？（检查/点评）现在，用户可以登录了，登录后他们应该看到什么？当然是他们的知识点列表！今天我们就来开发这个核心功能。”

2.  **改造 Axios 实例以携带 Token**
    *   **问题引入：** “我们之前创建的知识点 API 是受保护的，请求时必须携带 JWT。我们总不能在每次请求时都手动添加 `Authorization` 头吧？这太麻烦了。我们可以在 Axios 的请求拦截器里统一处理。”
    *   **修改 `src/api/axios.js`：**
        ```javascript
        // src/api/axios.js
        import axios from 'axios';

        const apiClient = axios.create({
            baseURL: 'http://localhost:3000/api',
            headers: {
                'Content-Type': 'application/json',
            },
        });

        // 添加一个请求拦截器
        apiClient.interceptors.request.use(
            (config) => {
                const token = localStorage.getItem('token'); // 从localStorage获取token
                if (token) {
                    config.headers['x-auth-token'] = token; // 将token添加到请求头
                }
                return config;
            },
            (error) => {
                return Promise.reject(error);
            }
        );

        export default apiClient;
        ```
    *   **讲解：** “这段代码就像是在我们每次发快递（请求）前，都有一个安检员（拦截器）自动检查我们口袋里有没有门票（Token），如果有，就把它贴在快递盒上（请求头）。这样，所有使用 `apiClient` 发送的请求就都自动带上认证信息了。”

3.  **在主页获取并展示知识点列表**
    *   **讲解 `useEffect` Hook：** “`useEffect` 是 React 中处理**副作用 (Side Effects)** 的钩子。什么是副作用？任何与组件渲染无关的操作，比如：**发送网络请求**、手动操作DOM、设置定时器等。我们希望在组件**加载完成时**去获取数据，`useEffect` 正是做这个的完美工具。”
    *   **修改 `src/pages/DashboardPage.jsx`：**
        ```jsx
        // src/pages/DashboardPage.jsx
        import { useState, useEffect } from 'react';
        import apiClient from '../api/axios';
        import { Link } from 'react-router-dom';

        function DashboardPage() {
            const [knowledgePoints, setKnowledgePoints] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState('');

            useEffect(() => {
                const fetchKnowledgePoints = async () => {
                    try {
                        setLoading(true);
                        const response = await apiClient.get('/knowledge-points');
                        setKnowledgePoints(response.data);
                    } catch (err) {
                        setError('获取知识点失败');
                        console.error(err);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchKnowledgePoints();
            }, []); // 第二个参数是依赖数组，空数组[]表示这个effect只在组件首次挂载时运行一次

            if (loading) return <p>加载中...</p>;
            if (error) return <p style={{ color: 'red' }}>{error}</p>;

            return (
                <div>
                    <h1>我的知识点</h1>
                    <Link to="/kp/new">
                      <button>+ 新建知识点</button>
                    </Link>
                    
                    <div style={{ marginTop: '20px' }}>
                        {knowledgePoints.length === 0 ? (
                            <p>你还没有任何知识点，快去创建一个吧！</p>
                        ) : (
                            <ul>
                                {knowledgePoints.map((kp) => (
                                    <li key={kp._id} style={{ border: '1px solid #ccc', margin: '10px', padding: '10px' }}>
                                        <h2>{kp.title}</h2>
                                        {/* 我们将在这里渲染内容 */}
                                        <p>状态: {kp.status}</p>
                                    </li>
                                ))}
                            </ul>
                        )}
                    </div>
                </div>
            );
        }
        export default DashboardPage;
        ```

---

#### **第二部分：创建与编辑知识点 (约75分钟)**

**教师带领学生一步步敲代码：**

“列表有了，现在我们需要一个地方来创建和编辑这些知识点。我们将创建一个新的页面来承载这个功能。”

1.  **升级输入体验：集成富文本编辑器**
    *   **讲解：** “目前我们使用原生的`<textarea>`来输入内容，这太简陋了。为了让用户能更直观地编辑格式，我们将集成一个所见即所得（WYSIWYG）的富文本编辑器。我们推荐使用 `React-Quill`，它功能强大且易于集成。”
    *   **安装 `React-Quill`:**
        ```bash
        npm install react-quill
        ```
    *   **修改 `KnowledgePointFormPage.jsx`**
        ```jsx
        // src/pages/KnowledgePointFormPage.jsx
        import { useState, useEffect } from 'react';
        import { useParams, useNavigate } from 'react-router-dom';
        import apiClient from '../api/axios';
        import ReactQuill from 'react-quill'; // 引入ReactQuill
        import 'react-quill/dist/quill.snow.css'; // 引入默认的雪花主题样式

        function KnowledgePointFormPage() {
            const [title, setTitle] = useState('');
            const [content, setContent] = useState(''); // content现在将存储HTML
            const { id } = useParams();
            const navigate = useNavigate();
            const isEditing = Boolean(id);

            // ... (useEffect to fetchKp remains the same)

            const handleSubmit = async (e) => {
                e.preventDefault();
                // 注意：content现在是HTML，后端需要能处理HTML
                const kpData = { title, content };
                try {
                    if (isEditing) {
                        await apiClient.put(`/knowledge-points/${id}`, kpData);
                    } else {
                        await apiClient.post('/knowledge-points', kpData);
                    }
                    navigate('/');
                } catch (error) {
                    console.error('保存知识点失败', error);
                }
            };

            return (
                <div>
                    <h1>{isEditing ? '编辑知识点' : '新建知识点'}</h1>
                    <form onSubmit={handleSubmit}>
                        <div>
                            <label>标题:</label>
                            <input type="text" value={title} onChange={(e) => setTitle(e.target.value)} style={{ width: '100%', padding: '8px' }} />
                        </div>
                        <div style={{ marginTop: '1rem', marginBottom: '1rem' }}>
                            <label>内容:</label>
                            {/* 将 textarea 替换为 ReactQuill */}
                            <ReactQuill theme="snow" value={content} onChange={setContent} style={{ height: '300px' }} />
                        </div>
                        <button type="submit" style={{ marginTop: '4rem' }}>{isEditing ? '更新' : '创建'}</button>
                    </form>
                </div>
            );
        }
        export default KnowledgePointFormPage;
        ```
    *   **讲解 `useParams`:** “`useParams` 是 `react-router-dom` 提供的钩子，可以方便地获取到 URL 中的动态参数，比如 `/kp/edit/123` 里的 `123`。”
    *   **重要安全提示：** “请注意，`React-Quill` 生成的内容是 **HTML**，而不是Markdown。这就意味着，我们在渲染这些内容时，之前学到的 `DOMPurify` 就成了**必需品**，而不再是可选项！我们将在渲染部分详细讨论如何安全地处理这些HTML。”

2.  **在 `App.jsx` 中添加新路由**
    *   修改 `src/App.jsx`，在 `ProtectedRoute` 内部添加新路由。
        ```jsx
        // src/App.jsx
        import KnowledgePointFormPage from './pages/KnowledgePointFormPage'; // 引入

        // ...
        <Route element={<ProtectedRoute />}>
          <Route path="/" element={<DashboardPage />} />
          <Route path="/kp/new" element={<KnowledgePointFormPage />} />
          <Route path="/kp/edit/:id" element={<KnowledgePointFormPage />} />
        </Route>
        // ...
        ```
3.  **在 `DashboardPage.jsx` 中添加编辑和删除按钮**
    *   修改 `DashboardPage.jsx` 中的列表项 `<li>`：
        ```jsx
        // ... in DashboardPage.jsx, inside the map function
        <li key={kp._id} /* ... */>
            <h2>{kp.title}</h2>
            {/* ... */}
            <Link to={`/kp/edit/${kp._id}`}>
                <button>编辑</button>
            </Link>
            <button onClick={() => handleDelete(kp._id)} style={{ marginLeft: '10px', background: 'red' }}>删除</button>
        </li>
        // ...
        ```
    *   在 `DashboardPage` 组件中添加 `handleDelete` 函数：
        ```jsx
        // src/pages/DashboardPage.jsx
        // ...
        const handleDelete = async (id) => {
            if (window.confirm('你确定要删除这个知识点吗？')) {
                try {
                    await apiClient.delete(`/knowledge-points/${id}`);
                    // 从前端状态中移除被删除的项，避免刷新页面
                    setKnowledgePoints(knowledgePoints.filter(kp => kp._id !== id));
                } catch (error) {
                    console.error('删除失败', error);
                }
            }
        };
        // ...
        ```

---

#### **第三部分：富文本渲染 - 让内容“活”起来 (约75分钟)**

**教师讲解与带领编码：**

“现在我们的内容只是普通的文本，非常枯燥。接下来，我们要施展‘魔法’，让用户输入的 Markdown、数学公式和图表都能被正确地渲染出来！但在施法之前，我们必须先建立一个‘安全护盾’。”

1.  **安全第一：防止XSS攻击 (Cross-Site Scripting)**
    *   **讲解（极其重要）：** “当我们在页面上显示用户输入的内容时，会面临一种最常见、也最危险的Web攻击——XSS攻击。想象一下，如果一个恶意用户输入的不是普通的Markdown，而是一段`<script>`代码，比如 `<script>alert('你的token是：' + localStorage.getItem('token'))</script>`。如果我们不加处理地直接把这段内容渲染到页面上，浏览器就会执行它！这样，攻击者就能偷取用户的登录信息，甚至控制用户的账户。”
    *   **解决方案：内容消毒 (Sanitization)**
        *   “幸运的是，我们即将使用的 `react-markdown` 库在默认情况下已经帮我们处理了大部分XSS风险，它不会执行恶意的脚本。但作为专业的开发者，我们必须建立起‘零信任’的安全意识。在未来的开发中，你可能会遇到需要直接渲染HTML的场景（比如使用所见即所得的富文本编辑器），那时，我们就必须手动为内容‘消毒’。”
        *   “我们将学习使用 `DOMPurify` 这个行业标准的库来完成这项工作。它就像一个过滤器，能把HTML内容中所有危险的、可执行的部分全部清洗掉，只留下安全的、用于展示的标签。”
    *   **安装 `DOMPurify`:**
        ```bash
        npm install dompurify
        ```

2.  **渲染 Markdown (安全的方式)**
    *   **安装 `react-markdown` 和插件：**
        ```bash
        npm install react-markdown remark-gfm
        ```
    *   **讲解：** “`react-markdown` 是一个专门用于在 React 中渲染 Markdown 的库。我们将结合 `DOMPurify` 来构建一个双重保险的安全渲染流程。”
    *   **修改 `DashboardPage.jsx` 来渲染内容：**
        ```jsx
        // src/pages/DashboardPage.jsx
        import ReactMarkdown from 'react-markdown';
        import remarkGfm from 'remark-gfm';
        import DOMPurify from 'dompurify'; // 引入DOMPurify

        // ... in the map function
        <li key={kp._id} /* ... */>
            <h2>{kp.title}</h2>
            <div className="markdown-content" style={{ background: '#f9f9f9', padding: '10px', borderRadius: '5px' }}>
                {/* 
                  虽然react-markdown默认是安全的，但我们这里演示如何添加额外的安全层。
                  在未来的富文本编辑器场景中，这一步是必须的。
                  const cleanHtml = DOMPurify.sanitize(rawHtmlFromEditor);
                  <div dangerouslySetInnerHTML={{ __html: cleanHtml }} />
                */}
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                    {kp.content}
                </ReactMarkdown>
            </div>
            {/* ... buttons */}
        </li>
        // ...
        ```
    *   **教师强调:** “在这个场景下，`react-markdown` 已经足够安全。我们引入 `DOMPurify` 的目的是为了让大家掌握这个至关重要的安全工具，当你们以后使用像 `React-Quill` 或 `Tiptap` 这样的富文本编辑器，并需要直接渲染HTML时，`DOMPurify.sanitize()` 将是你们的救星。”
    *   **测试：** 去创建一个新的知识点，内容包含 Markdown 语法和一段尝试性的XSS代码，比如：
        ```markdown
        # 这是一个正常的标题

        <script>alert('Hacked!')</script>

        <img src="invalid-source" onerror="alert('XSS via image')" />
        ```
        保存后，回到主页，你会发现 `<script>` 标签和 `onerror` 事件都被 `react-markdown` 过滤掉了，没有任何弹窗出现，证明了其安全性。

2.  **挑战目标：渲染 LaTeX 数学公式**
    *   **安装 `react-katex` 和 `remark-math` `rehype-katex`：**
        ```bash
        npm install react-katex remark-math rehype-katex
        ```
    *   **讲解：** “`remark-math` 插件负责识别 Markdown 中的数学公式语法（如 `$E=mc^2$`），`rehype-katex` 插件则负责调用 `KaTeX` 库将它们渲染出来。”
    *   **修改 `DashboardPage.jsx` 的 `ReactMarkdown` 组件：**
        ```jsx
        // src/pages/DashboardPage.jsx
        import remarkMath from 'remark-math';
        import rehypeKatex from 'rehype-katex';
        import 'katex/dist/katex.min.css'; // 引入KaTeX的CSS样式

        // ... in ReactMarkdown component
        <ReactMarkdown
            remarkPlugins={[remarkGfm, remarkMath]}
            rehypePlugins={[rehypeKatex]}
        >
            {kp.content}
        </ReactMarkdown>
        // ...
        ```
    *   **测试：** 编辑一个知识点，加入 LaTeX 内容：
        ```markdown
        这是一个行内公式: $E=mc^2$。

        这是一个块级公式:
        $$
        \int_a^b f(x) dx = F(b) - F(a)
        $$
        ```
        保存后，你应该能看到渲染精美的数学公式。

3.  **挑战目标：渲染 Mermaid 图表**
    *   **安装 `mermaid`:**
        ```bash
        npm install mermaid
        ```
    *   **讲解：** “Mermaid 的集成稍微复杂一些，因为它需要在客户端动态渲染 SVG。我们可以在 `useEffect` 中找到所有 mermaid 代码块并渲染它们。”
    *   **在 `DashboardPage.jsx` 中添加 Mermaid 渲染逻辑：**
        ```jsx
        // src/pages/DashboardPage.jsx
        import mermaid from 'mermaid';

        // ... in DashboardPage component
        useEffect(() => {
            mermaid.initialize({ startOnLoad: true, theme: 'default' });
            mermaid.contentLoaded();
        }, [knowledgePoints]); // 当知识点列表变化时，重新运行Mermaid
        
        // ...
        // 在ReactMarkdown组件外部，因为Mermaid不是通过插件工作的
        // 在li内部添加
        {/* <div className="mermaid">{kp.content_containing_mermaid}</div> */}
        // 这是一个简化的演示，实际应用中，我们需要用一个自定义组件来处理代码块，
        // 判断语言是否为mermaid，然后调用mermaid.render()。
        // 下面提供一个更完整的做法：
        ```
    *   **更健壮的做法（自定义组件）：**
        在 `ReactMarkdown` 的 `components` prop 中覆盖代码块的渲染。
        ```jsx
        // In ReactMarkdown component
        <ReactMarkdown
            // ... other plugins
            components={{
                code({node, inline, className, children, ...props}) {
                    const match = /language-(\w+)/.exec(className || '')
                    if (match && match[1] === 'mermaid') {
                        // 使用useEffect确保只在客户端渲染
                        const [svg, setSvg] = useState(null);
                        useEffect(() => {
                           mermaid.render(`mermaid-${node.position.start.line}`, String(children).replace(/\n$/, ''), (svgCode) => setSvg(svgCode));
                        }, [children, node.position.start.line]);

                        return <div dangerouslySetInnerHTML={{ __html: svg }} />;
                    }
                    // 否则，渲染为普通代码块
                    return <code className={className} {...props}>{children}</code>
                }
            }}
        >
          {kp.content}
        </ReactMarkdown>
        ```
    *   **测试：** 编辑知识点，加入 Mermaid 语法：
        ```markdown
        这是一个流程图:
        ```mermaid
        graph TD;
            A[开始] --> B(处理);
            B --> C{判断};
            C -->|是| D[结束];
            C -->|否| B;
        ```
        ```
        保存后，你应该能看到一个渲染出来的流程图。

---

#### **四、 课堂总结与作业 (15分钟)**

*   **总结：**
    *   “今天我们完成了‘费曼学习平台’的核心内容模块！我们不仅实现了知识点的完整CRUD功能，还掌握了前端开发中一项非常重要的技能——富文本渲染。通过`react-markdown`及其插件，我们的应用现在能够展示格式丰富的文本、严谨的数学公式和清晰的图表，这极大地提升了用户体验和平台的核心价值。”
*   **课后作业：**
    1.  **必须完成：** 确保知识点的创建、读取（列表）、更新、删除功能全部正常工作。
    2.  **富文本实践：** 至少成功渲染出包含表格、公式和Mermaid图表的知识点。
    3.  **UI优化（选做）：** 使用简单的CSS，美化知识点列表项和表单页面，使其看起来更像一个真正的产品。
*   **预告下次课内容：**
    *   “内容可以输入和展示了，但‘费曼学习法’的核心还没实现！下次课，我们将进入项目的趣味与挑战并存的阶段——集成多媒体功能。我们将学习如何使用浏览器的API进行**录音**，并将录制的音频上传到后端，调用**百度语音识别API**，将用户的口头复述转换成文字，为后续的AI评价打下基础！”

**答疑环节，课程结束。**