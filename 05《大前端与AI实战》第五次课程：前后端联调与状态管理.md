好的，这是为您的《大前端与AI实战》实训课程设计的第五次课程的详细内容。这次课程是前后端联通的关键一环，将之前孤立的前端界面与后端API真正连接起来，实现完整的用户认证流程。

---

### **《大前端与AI实战》第五次课程：前后端联调与状态管理**

**课程主题：** 打通“任督二脉”：API请求与全局用户状态
**总时长：** 4学时 (约3-3.5小时教学，半小时答疑与休息)

#### **一、 本次课程目标 (Objectives)**

在本次课程结束后，每位同学都应该能够：
1.  **理解** 跨域（CORS）问题产生的原因，并在后端项目中进行正确配置以解决它。
2.  **使用 `axios`** 库在 React 应用中发送异步网络请求（POST）。
3.  **完成** 用户注册和登录页面的功能，实现与后端API的真实交互。
4.  **理解** 全局状态管理的必要性，并**使用 React Context API** 来管理用户的登录状态和Token。
5.  **创建** 一个“路由守卫”（Protected Route），保护需要登录才能访问的页面（如仪表盘）。

#### **二、 核心关键词 (Keywords)**

*   跨域 (CORS - Cross-Origin Resource Sharing)
*   `axios`
*   异步请求 (Async/Await)
*   `localStorage`
*   React Context API (`createContext`, `useContext`, Provider)
*   路由守卫 (Protected Route)

---

### **三、 详细教学流程 (Step-by-Step Guide)**

---

#### **第一部分：跨域问题与后端配置 (约30分钟)**

**教师讲解与后端代码修改：**

1.  **回顾与承接**
    *   “上节课我们搭建了前端的骨架，并完成了登录和注册的静态页面。大家的作业（注册页面表单）都完成了吧？今天，我们要让这些表单‘活’起来，点击按钮时，不再是打印到控制台，而是真正地把数据发送到我们的后端服务器！”

2.  **讲解跨域（CORS）**
    *   **情景引入：** “在动手之前，我们必须先了解一个浏览器安全策略——**同源策略 (Same-Origin Policy)**。它规定，一个源（域名、协议、端口号三者都相同）的网页脚本，不能随意访问另一个源的资源。”
    *   **类比：** “这就像小区的门禁系统。A小区的住户（我们的前端，运行在 `http://localhost:5173`）不能直接去刷B小区（我们的后端，运行在 `http://localhost:3000`）的门禁卡拿东西。因为它们的‘源’不同（端口号不同）。”
    *   **什么是CORS：** “CORS (跨域资源共享) 就像是B小区的物业（后端服务器）给A小区的住户开了一张‘临时通行证’。它通过特定的HTTP头告诉浏览器：‘虽然我们不是一个源，但我允许这个来自 `http://localhost:5173` 的请求访问我的资源’。浏览器看到这个许可后，才会放行。”

3.  **在后端项目中配置CORS**
    *   **打开后端项目** (`feynman-platform-backend`)。
    *   在终端中安装 `cors` 中间件：
        ```bash
        npm install cors
        ```
    *   **修改 `index.js` 文件：**
        ```javascript
        // backend/index.js
        const express = require('express');
        const cors = require('cors'); // 1. 引入cors
        const mongoose = require('mongoose');
        require('dotenv').config();

        const app = express();
        
        // ...
        
        // --- 中间件 ---
        app.use(cors()); // 2. 在所有路由之前使用cors中间件
        app.use(express.json());

        // --- 路由 ---
        app.use('/api/users', require('./routes/users'));
        app.use('/api/knowledge-points', require('./routes/knowledgePoints'));

        // ...
        ```
    *   **讲解：** “`app.use(cors())` 这行代码，就相当于给我们的后端服务器开启了CORS支持，允许所有来源的跨域请求。在生产环境中，我们还可以配置只允许特定的来源，比如我们正式上线的网站域名。”
    *   **重要：** **重启后端服务器** (`Ctrl+C`停止，再`node index.js`启动) 使配置生效。

---

#### **第二部分：使用 Axios 发送API请求 (约75分钟)**

**教师带领学生修改前端代码：**

1.  **安装 Axios**
    *   **打开前端项目** (`feynman-platform-frontend`)。
    *   在终端中安装 `axios`：
        ```bash
        npm install axios
        ```
    *   **讲解：** “`axios` 是一个非常流行的、基于 Promise 的 HTTP客户端，它能让我们在浏览器和 Node.js 中都非常方便地发送网络请求。”

2.  **封装 Axios 实例（最佳实践）**
    *   在 `src/` 目录下新建一个 `api` 文件夹。
    *   在 `src/api` 中新建 `axios.js` 文件：
        ```javascript
        // src/api/axios.js
        import axios from 'axios';

        const apiClient = axios.create({
            baseURL: 'http://localhost:3000/api', // 后端API的基础路径
            headers: {
                'Content-Type': 'application/json',
            },
        });

        export default apiClient;
        ```
    *   **讲解：** “创建一个专用的`apiClient`实例有几个好处：1. 统一配置API的根路径，以后后端地址变了只改这一个地方。2. 方便后续统一处理请求头，比如添加认证Token。”

3.  **改造注册页面 (`RegisterPage.jsx`)**
    *   修改 `src/pages/RegisterPage.jsx`：

    ```jsx
    // src/pages/RegisterPage.jsx
    import { useState } from 'react';
    import apiClient from '../api/axios'; // 1. 引入apiClient
    import { useNavigate } from 'react-router-dom'; // 2. 引入useNavigate用于跳转

    function RegisterPage() {
      const [formData, setFormData] = useState({
        username: '',
        email: '',
        password: '',
      });
      const [error, setError] = useState('');
      const navigate = useNavigate(); // 3. 获取navigate函数

      const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
      };

      const handleSubmit = async (e) => { // 4. 将函数改为async
        e.preventDefault();
        setError(''); // 清空之前的错误信息
        try {
          // 5. 使用apiClient发送POST请求
          const response = await apiClient.post('/users/register', formData);
          console.log('注册成功:', response.data);
          // 6. 注册成功后跳转到登录页
          navigate('/login');
        } catch (err) {
          console.error('注册失败:', err.response.data);
          setError(err.response.data.msg || '注册失败，请稍后再试'); // 7. 显示错误信息
        }
      };

      return (
        <div>
          <h1>注册</h1>
          <form onSubmit={handleSubmit}>
            {/* ... input fields with name attributes */}
            <input name="username" type="text" value={formData.username} onChange={handleChange} placeholder="用户名" required />
            <input name="email" type="email" value={formData.email} onChange={handleChange} placeholder="邮箱" required />
            <input name="password" type="password" value={formData.password} onChange={handleChange} placeholder="密码" required />
            <button type="submit">注册</button>
          </form>
          {error && <p style={{ color: 'red' }}>{error}</p>} {/* 8. 显示错误提示 */}
        </div>
      );
    }
    export default RegisterPage;
    ```
    *   **带领学生测试：** 填写注册表单，点击注册。观察网络请求（浏览器 F12 -> Network），查看后端服务器的日志，以及 MongoDB 数据库中是否新增了用户。尝试用已存在的邮箱注册，看看前端是否显示了错误提示。

4.  **改造登录页面 (`LoginPage.jsx`)**
    *   （此部分可以作为课堂快速练习，让学生模仿注册页面来写，老师再进行讲解和修正）
    *   代码与注册页面非常相似，只是API路径和处理逻辑不同。登录成功后，我们会得到一个`token`。
    *   **临时处理：** “登录成功后，我们暂时先把 `token` 打印出来，下一节，我们再来思考如何全局保存它。”
        ```jsx
        // 在 LoginPage.jsx 的 handleSubmit 中
        const response = await apiClient.post('/users/login', { email, password });
        console.log('登录成功，Token:', response.data.token);
        // navigate('/'); // 暂时先不跳转
        ```

---

#### **第三部分：全局状态管理 - React Context (约75分钟)**

**教师讲解与带领编码：**

“我们现在能在登录时拿到 Token，但问题来了：其他组件（比如知识点页面）怎么知道用户已经登录了？怎么拿到这个 Token 去请求受保护的 API？把 Token 通过 Props 一层层传递下去太麻烦了。我们需要一个‘全局公告板’——React Context。”

1.  **Context API 概念讲解**
    *   **类比：** “Context 就像是在学校的广播系统。任何一个班级（组件）里的学生（子组件），只要想听广播，就能直接听到，而不需要校长（根组件）把消息通过班主任、小组长一层层传达下来。”
    *   **三要素：**
        *   `createContext`: 创建一个广播频道。
        *   `Provider` (提供者): 在广播站（高层组件）用它来发布消息（提供 state 和函数）。
        *   `useContext` (消费者): 在任何教室（任何子组件）里用它来收听这个频道的消息。

2.  **创建认证上下文 (Auth Context)**
    *   在 `src/` 下新建 `context` 文件夹。
    *   在 `src/context` 中新建 `AuthContext.js` 文件。
    ```javascript
    // src/context/AuthContext.js
    import { createContext, useState, useContext, useEffect } from 'react';

    const AuthContext = createContext(null);

    export function AuthProvider({ children }) {
        const [token, setToken] = useState(localStorage.getItem('token')); // 1. 从localStorage初始化token
        const [user, setUser] = useState(null); // 可以在这里保存解码后的用户信息

        useEffect(() => {
            if (token) {
                // 当token变化时，更新localStorage
                localStorage.setItem('token', token);
                // 可以在这里解码token获取用户信息，并设置user state
                // 暂时简化处理
            } else {
                localStorage.removeItem('token');
            }
        }, [token]);

        const login = (newToken) => {
            setToken(newToken);
        };

        const logout = () => {
            setToken(null);
            setUser(null);
        };

        // 2. 将 state 和函数通过 value prop 提供出去
        const value = { token, user, login, logout };

        return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
    }

    // 3. 创建一个自定义Hook，方便其他组件使用
    export function useAuth() {
        return useContext(AuthContext);
    }
    ```
    **讲解 `localStorage`**: "这是一个浏览器提供的本地存储功能，可以把数据（比如Token）存下来，这样即使用户刷新了页面，登录状态也不会丢失。"

3.  **在 `main.jsx` 中使用 `AuthProvider`**
    *   修改 `src/main.jsx`，用 `AuthProvider` 包裹整个应用。
        ```jsx
        // src/main.jsx
        // ...
        import { AuthProvider } from './context/AuthContext'; // 引入AuthProvider

        ReactDOM.createRoot(document.getElementById('root')).render(
          <React.StrictMode>
            <BrowserRouter>
              <AuthProvider> {/* 用AuthProvider包裹App */}
                <App />
              </AuthProvider>
            </BrowserRouter>
          </React.StrictMode>,
        );
        ```

4.  **在 `LoginPage.jsx` 中使用 `useAuth`**
    *   修改 `src/pages/LoginPage.jsx` 的 `handleSubmit` 函数。
        ```jsx
        // src/pages/LoginPage.jsx
        import { useAuth } from '../context/AuthContext'; // 引入useAuth

        // ...
        const { login } = useAuth(); // 从Context中获取login函数
        const navigate = useNavigate();

        const handleSubmit = async (e) => {
            e.preventDefault();
            try {
                const response = await apiClient.post('/users/login', { email, password });
                login(response.data.token); // 调用Context的login函数来更新全局token
                navigate('/'); // 登录成功后跳转到主页
            } catch (err) {
                // ...错误处理
            }
        };
        // ...
        ```

---

#### **第四部分：路由守卫 - 保护你的页面 (约30分钟)**

**教师讲解与带领编码：**

“现在虽然能登录了，但即使用户没登录，直接在浏览器地址栏输入 `/` 还是能看到 `DashboardPage`。这不安全。我们需要一个‘路由守卫’组件。”

1.  **创建 `ProtectedRoute` 组件**
    *   在 `src/components` 文件夹下新建 `ProtectedRoute.jsx`。

    ```jsx
    // src/components/ProtectedRoute.jsx
    import { useAuth } from '../context/AuthContext';
    import { Navigate, Outlet } from 'react-router-dom';

    function ProtectedRoute() {
        const { token } = useAuth(); // 从全局状态获取token

        // 如果没有token，重定向到登录页
        if (!token) {
            return <Navigate to="/login" replace />; 
            // replace: 替换当前历史记录，用户点后退不会回到受保护的页面
        }

        // 如果有token，正常渲染子路由（通过Outlet）
        return <Outlet />;
    }
    export default ProtectedRoute;
    ```

2.  **修改 `App.jsx` 的路由配置**
    *   修改 `src/App.jsx`，使用 `ProtectedRoute` 来包裹需要保护的路由。

    ```jsx
    // src/App.jsx
    // ... imports
    import Layout from './components/Layout';
    import ProtectedRoute from './components/ProtectedRoute'; // 引入

    function App() {
      return (
        <Routes>
          <Route element={<Layout />}>
            {/* 公共路由 */}
            <Route path="/login" element={<LoginPage />} />
            <Route path="/register" element={<RegisterPage />} />
            
            {/* 受保护的路由 */}
            <Route element={<ProtectedRoute />}>
              <Route path="/" element={<DashboardPage />} />
              {/* 未来其他的受保护页面也可以放在这里 */}
            </Route>
          </Route>
        </Routes>
      );
    }
    export default App;
    ```
*   **验证：**
    1.  清空浏览器缓存（Application -> localStorage），确保没有 token。
    2.  直接访问 `http://localhost:5173/`，观察是否被自动跳转到了 `/login` 页面。
    3.  正常登录，登录成功后应该会跳转到 `/` 并看到 Dashboard 内容。
    4.  刷新页面，应该仍然停留在 Dashboard 页面，不会被踢回登录页。

---

#### **五、 课堂总结与作业 (15分钟)**

*   **总结：**
    *   “今天是非常关键的一节课！我们解决了跨域问题，学会了使用`axios`进行前后端通信，并成功实现了用户的注册和登录。更重要的是，我们掌握了 React Context 这一强大的全局状态管理工具，并用它构建了路由守卫，确保了应用的安全性。我们的应用现在已经是一个功能完备、流程闭环的系统了！”
*   **课后作业：**
    1.  **必须完成：** 确保完整的注册->登录->访问受保护页面->刷新保持登录->退出登录（可选）流程能够顺畅运行。
    2.  **功能完善：**
        *   在导航栏（`Layout.jsx`）中，根据登录状态显示不同的内容。如果已登录，显示“主页”和“退出登录”按钮；如果未登录，显示“登录”和“注册”链接。（提示：使用 `useAuth` 获取 `token` 和 `logout` 函数）。
        *   实现“退出登录”按钮的功能，点击时调用 `useAuth` 中的 `logout` 函数，并跳转到登录页。
*   **预告下次课内容：**
    *   “用户系统已经完善，下节课我们将开始开发项目的核心功能——知识点学习模块。我们将在前端创建知识点列表和详情页，调用后端的CRUD API，并首次接触富文本渲染，让Markdown、LaTeX和Mermaid在我们的页面上‘活’起来！”

**答疑环节，课程结束。**